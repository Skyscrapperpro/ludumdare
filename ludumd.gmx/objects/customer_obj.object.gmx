<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>editor_client</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>door_trigger</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///var init
x1=x;
y1=y;
x2=x;
y2=y;

in_angle = false;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///spawn
x=SPAWNX;
y=SPAWNY;
line=0;

for (i=0;i&lt;LINENUMBER;i++)
{
    if (customer_manager_obj.lines[i] &lt; customer_manager_obj.lines[line])
        line=i;
}
customer_manager_obj.lines[line]++;
prevcustomer = customer_manager_obj.customers[line];
customer_manager_obj.customers[line]=id;
nextcustomer = -1;
prevcustomer.nextcustomer = id;
looking_right = choose(true, false);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw var
sp3d = customer;
subi = 0;
ilimit = sprite_get_number(customer);
dying = false;
dedi = 0;
dedlimit = sprite_get_number(customer_ded);

main_spr = customer;
ded_spr = customer_ded;
//scared_spr = 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement var
rand = random(CUSTOMERSEPRND);
if (prevcustomer == -1)
{
    targetx = 200 - rand;
    targety = FIRSTLINEY + (line * LINESEPARATION) - (CUSTOMERSEPRND/2) + rand;
    angle = point_direction(x, y, targetx, targety);
}
else
{
    targetx = prevcustomer.x - CUSTOMERSEP - rand;
    targety = FIRSTLINEY + (line * LINESEPARATION) - (CUSTOMERSEPRND/2) + rand;
    angle = point_direction(x, y, targetx, targety);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation
if ((x != targetx) &amp;&amp; (y != targety))
{
    if ((subi + 1) &gt; ilimit) then subi = 1;
    else subi++;
}
else subi = 0;
if (dying)
{ 
    if ((dedi + 2) &gt; dedlimit) {
        //Jimmy's
        if (instance_exists(nextcustomer)) nextcustomer.prevcustomer=-1;
        if (instance_exists(prevcustomer)) prevcustomer.nextcustomer=-1;
        customer_manager_obj.lines[line]--;
        if (customer_manager_obj.customers[line]==id)
        {
            customer_manager_obj.customers[line]=-1;
        }
        //
        //Delete from array
        var i = instance_number(customer_obj)-1;
        var prev = global.customers[i];
        var prev0 = global.customers[i];
        while(global.customers[i] != id)
        {
            prev0 = global.customers[i];
            global.customers[i] = prev;
            prev = prev0;
            i--;
        }
        global.customers[i] = prev;
        //
        instance_destroy();
    }
    else dedi++;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>612</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>-1</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_if_variable</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>dying</string>
          </argument>
          <argument>
            <kind>0</kind>
            <string>false</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>422</id>
        <kind>1</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///kill me with raycast
var angleto1=point_direction(player_obj.x,player_obj.y,x1,y1)-90;
var angleto2=point_direction(player_obj.x,player_obj.y,x2,y2)-90;
var anglemin=0;
var anglemax=0;
var target=point_direction(player_obj.x, player_obj.y, x, y) - 90;

while(angleto1 &lt; -180)
    angleto1+=360;
while(angleto1 &gt;= 180)
    angleto1-=360;
while(angleto2 &lt;- 180)
    angleto2+=360;
while(angleto2 &gt;= 180)
    angleto2-=360;
while(target &lt; -180)
    target+=360;
while(target &gt;= 180)
    target-=360;


if (angleto1 &lt; angleto2){anglemin = angleto1; anglemax = angleto2; }
else {anglemin = angleto2; anglemax = angleto1; }

in_angle = false;
if ((target &lt; anglemax) &amp;&amp; (target &gt; anglemin)){
    if (player_obj.angle &gt; anglemin)
    if (player_obj.angle &lt; anglemax)
    if (player_obj.guni == sprite_get_number(gunshot)/2)
    if (player_obj.handitem == 1)
        in_angle = true;
}
else
{
    if ((player_obj.angle &lt; anglemin) || (player_obj.angle &gt; anglemax))
    if (point_distance(player_obj.x, player_obj.y, x, y) &lt; ITEMRANGE)
    if (player_obj.guni == sprite_get_number(gunshot)/2)
    if (player_obj.handitem == 1)
        in_angle = true;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Check zombie
if (instance_exists(zombie_obj))
{
    var near = instance_nearest(x, y, zombie_obj);
    if (point_distance(x, y, near.x, near.y) &lt; CUSTOMERCOLLISION)
    {
        dying = true;
        audio_play_sound(elvis_snd, 2, false);
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Movement
var xsonic = lengthdir_x(CUSTOMERSPEED, angle);
var ysonic = lengthdir_y(CUSTOMERSPEED, angle);


//Collisions
if (xsonic != 0)
{
    if !place_free(x+xsonic,y)
    { //Estos dos ifs testean la posición x y la x,y por separado, para que si te chocas te deslices por la pared
        if xsonic&gt;0 then move_contact_solid(0,xsonic)
        if xsonic&lt;0 then move_contact_solid(180,-xsonic)
        xsonic=0
    }
}
if (ysonic != 0)
{
    if !place_free(x+xsonic,y+ysonic)
    { //A veces este sistema hace que la colisión en diagonal no funcione y entres en el bloque, pero no es notable porque salir requiere la misma velocidad y nunca entras demasiados píxeles, esto aplicado al dash sí es notable
        if ysonic&gt;0 then move_contact_solid(270,ysonic)
        if ysonic&lt;0 then move_contact_solid(90,-ysonic)
        ysonic=0
    }
}

//X
if (x &lt; targetx)
{
    if ((x + xsonic) &gt; targetx) x = targetx;
    else x += xsonic;
}
else if (x &gt; targetx)
{
    if ((x + xsonic) &lt; targetx) x = targetx;
    else x += xsonic;
}
//Y
if (y &lt; targety)
{
    if ((y + ysonic) &gt; targety) y = targety;
    else y += ysonic;
}
else if (y &gt; targety)
{
    if ((y + ysonic) &lt; targety) y = targety;
    else y += ysonic;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>424</id>
        <kind>2</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Set depth
depth = point_distance(x, y, player_obj.x, player_obj.y)

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw sprite
if (ISPERSPECTIVE)
{
    var sprite, tex, w, h, subifinal;
    if (dying)
    {
        sprite = ded_spr;
        subifinal = dedi;
    }
    else
    {
        sprite = main_spr;
        subifinal = subi;
    }
    tex = sprite_get_texture(sprite, subifinal);
    w = sprite_get_width(sprite);
    h = sprite_get_height(sprite);
    z = - (h * SIZESCALE)/2;
    
    if (looking_right)
    {
        x1 = x + lengthdir_x(w, player_obj.angle) * SIZESCALE/2;
        y1 = y + lengthdir_y(w, player_obj.angle) * SIZESCALE/2;
        x2 = x - lengthdir_x(w, player_obj.angle) * SIZESCALE/2;
        y2 = y - lengthdir_y(w, player_obj.angle) * SIZESCALE/2;
    }
    else
    {
        x2 = x + lengthdir_x(w, player_obj.angle) * SIZESCALE/2;
        y2 = y + lengthdir_y(w, player_obj.angle) * SIZESCALE/2;
        x1 = x - lengthdir_x(w, player_obj.angle) * SIZESCALE/2;
        y1 = y - lengthdir_y(w, player_obj.angle) * SIZESCALE/2;
    }
    d3d_draw_wall(x1, y1, z, x2, y2, (h * SIZESCALE)/2, tex, 1, 1);
}
else
{
    image_angle = angle-90;
    draw_self();
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
